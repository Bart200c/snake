<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake game</title>
    <style>
          body {background-color: rgb(0, 0, 0);}
      body {
        margin: 0;
        overflow: hidden;
      }

      h1{
        color:rgb(200, 200, 200);
      }

      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        background-color: #555555;
      }
      li {
        display: inline;
        float: left;
      }
      li a {
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
      }

      li a:hover {
        background-color: #f78a41;
      }

      .center {
        margin: auto;
        width: 50%;
        border: 3px solid green;
        padding: 10px;
      }

    </style>
  </head>
  <body>
    <ul>
      <li><a href="https://skparab1.github.io">Home</a></li>
      <li><a href="https://skparab1.github.io/wordle/random">Wordle</a></li>
      <li><a href="https://skparab1.github.io/snake">Snake</a></li>
    </ul> 

    <h1>Snake game</h1>

    <!div class="center" style="width: 100%">
    <div style="float: left">
    <canvas class="myCanvas">
      <p>Rip ur browser doesnt support canvas :(( u shud switch to a better browser...</p>
      <canvas id="the-canvas" width="320" height="240" style="position:relative; right:300px;"></canvas>
    </canvas>
    </div>

    <script>

      // alr anindit here are the toggle constants
      const boardSize = 20; //so 20 means 20x20 and 40 would be 40x40 and you can change it to anything you want
      const speedfactor = 85; //about these many pixels per second (but not exactly)
      const pixelbackground1 = 'rgb(0,150,0)'; // this is like the pixel background pattern
      const pixelbackground2 = 'rgb(0,190,0)'; // its in rgb but you can make it hex or hsv if u want
      const bordercolor = 'rgb(0,100,0)'; //bordercolor
      const snakecolor1 = 'rgb(0,0,100)'; //snakecolor1
      const snakecolor2 = 'rgb(0,0,255)'; //snakecolor2
      const snakeheadcolor = 'rgb(200,100,0)'; //apple color
      const applecolor = 'rgb(150,0,0)'; //apple color
      const seglength = 75; //snake segment length in pixels
      const addlength = 100; //increase snake length by these many pixels when it eats an apple
      
      // dont do anythign below this
      const turningPrecision = true;

      function drawline(x,y,x1,y1,clr){
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = clr;
        ctx.moveTo(x,y);
        ctx.lineTo(x1,y1)
        ctx.stroke();
      }

      function drawboard(){
        ctx.beginPath();
        let x = 0;
        let actx = window.innerWidth/4;
        let clrnow = pixelbackground1;
        while (x < boardSize+2){
          let y = 0;
          let acty = 0;
          while (y < boardSize+4){
            if (clrnow == pixelbackground1){
              clrnow = pixelbackground2;
            } else {
              clrnow = pixelbackground1;
            }
            ctx.fillStyle = clrnow;
            if (x == 0 || x == boardSize+1 || y == 0 || y == boardSize+1){
              let reserve = clrnow;
              ctx.fillStyle = bordercolor;
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
              clrnow = reserve;
            } else {
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
            }
            acty += (height)/(boardSize+2);
            y += 1;
            //console.log('drew smth');
            }
          
          if (clrnow == pixelbackground1){
            clrnow = pixelbackground2;
          } else {
            clrnow = pixelbackground1;
          }
          actx += (height)/(boardSize+2);
          x += 1;
        }
        bounderies = [window.innerWidth/4+(height)/(boardSize+2)*1.5,(height)/(boardSize+2)*1.5,(window.innerWidth/4+height*((boardSize-1)/boardSize))-(height)/(boardSize+2)/2.5,height*(boardSize-1)/boardSize-(height)/(boardSize+2)/2];
      }

      function drawcircle(x,y,rad,circlr){
        ctx.beginPath();
        ctx.fillStyle = circlr;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      function drawapple(x,y,rad){
        ctx.beginPath();
        ctx.fillStyle = applecolor;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      const canvas = document.querySelector('.myCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = window.innerWidth/2+window.innerWidth/4; 
      const height = canvas.height = window.innerHeight-100;
      var bounderies = [0,0,0,0];
      var score = 0;
      canvas.style.left = "100px";
      canvas.style.top = "100px";

      //canvas outline
      //ctx.strokeStyle = 'rgb(125,125,125)';
      ctx.strokeRect(0, 0, width, height);
      //console.log('printeddd');

      drawboard();

      var speed = ((height)/(boardSize+2))/(100-speedfactor); // 1/4 square/frame?
      let xpos = window.innerWidth/4+window.innerWidth/40+(height)/(boardSize+2)*2;
      let ypos = ((height)/(boardSize+2)*1.5)+(height)/(boardSize+2)*(boardSize/2);
      var pointsArr = [xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
      var xd = speed;
      var yd = 0;
      var waiter = '';
      var applepos = [Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+window.innerWidth/4+window.innerWidth/40, Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+((height)/(boardSize+2)*1.5)];

      console.log(applepos);

      const sleep = ms => new Promise(res => setTimeout(res, ms));

      (async () => {
        let counter = 0;
        while (xpos >= bounderies[0] && xpos <= bounderies[2] && ypos >= bounderies[1] && ypos <= bounderies[3]){
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          //await sleep(2);
          drawboard();
          let i = 0;
          while (i <= pointsArr.length-1){
            if (i > (pointsArr.length-10)){
              drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakeheadcolor);
            } else {
              if (i % seglength*2 < seglength){
                drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor1);
              } else {
                drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor2);
              }
            }
            i += 2;
          }
          drawapple(applepos[0],applepos[1],(height)/(boardSize*2.2));
          xpos += xd;
          ypos += yd;
          counter += 1;
          await sleep(2);
          //console.log('drew at '+xpos+' '+ypos);
          pointsArr.push(xpos);
          pointsArr.push(ypos);
          pointsArr.shift();
          pointsArr.shift();

          if (Math.abs(xpos-applepos[0]) < 2 && Math.abs(ypos-applepos[1]) < 2){
            //basically you got it
            //relocate apple
            applepos = [Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+window.innerWidth/4+window.innerWidth/40, Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+((height)/(boardSize+2)*1.5)];

            //update score
            score += 1;
            var z1 = document.getElementById('score');
            z1.textContent = 'Score: '+score;

            //update length
            let z = 0;
            while (z <= addlength){
              pointsArr.push(-100);
              pointsArr.push(-100);
              z += 1;
            }
          }

          let ct3 = window.innerWidth/4+window.innerWidth/40;
          while (ct3 < xpos + (height)/(boardSize+2) && xd != 0){
            if (Math.abs(ct3-xpos) < 2){
              if (waiter == 'up'){
                xd = 0;
                yd = -speed;
              } else if (waiter == 'down'){
                xd = 0;
                yd = speed;
              }
              waiter = '';
            }
           ct3 += (height)/(boardSize+2);
          }

          ct3 = ((height)/(boardSize+2)*1.5);
          while (ct3 < ypos + (height)/(boardSize+2) && yd != 0){
            if (Math.abs(ct3-ypos) < 2){
              if (waiter == 'right'){
                xd = speed;
                yd = 0;
              } else if (waiter == 'left'){
                xd = -speed;
                yd = 0;
              }
              waiter = '';
            }
           ct3 += (height)/(boardSize+2);
          }
          //   ct1 += (height)/(boardSize+2);
        }
        //console.log('did whole thing');
        alert('You lost');
      })();

      (async () => {
      window.addEventListener("keydown", function(event) {

        if (event.defaultPrevented) {
          return;
        }

        const ctx = canvas.getContext('2d');
        
        let actkey = event.code.replace('Key','')
        let filterletters = 'QWERTYUIOPASDFGHJKLZXCVBNM';
        console.log('pressed'+actkey);

        if (actkey == 'ArrowLeft' || actkey == 'A'){
          waiter = 'left';
        }
        if (actkey == 'ArrowRight' || actkey == 'D'){
          // while (ct1 < ypos){
          //   ct1 += (height)/(boardSize+2);
          // }
          waiter = 'right';
        }
        if (actkey == 'ArrowUp' || actkey == 'W'){
          waiter = 'up';
        }
        if (actkey == 'ArrowDown' || actkey == 'S'){
          waiter = 'down';
        }

        // i think i get how to do it
        // just have a waiter variable thats set by this 
        // and then chnage directsion when it gets to the ting and clear the waiter

        //actkey is just the thing

        }, true);
      })();

    </script>
    </div style="float: left">
      <h1 id="score">Score: 0</h1>
    </div>
    <!/div>
    <h1 style="color:rgb(225, 252, 71);"> Note: if the game canvas does not cover the whole height of the screen, then reload.</h1>
  </body>
</html>
