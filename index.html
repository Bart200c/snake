<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake game</title>
    <style>
          body {background-color: rgb(0, 0, 0);}
      body {
        margin: 0;
        overflow: hidden;
      }

      h1{
        color:rgb(200, 200, 200);
      }

      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        background-color: #555555;
      }
      li {
        display: inline;
        float: left;
      }
      li a {
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
      }

      li a:hover {
        background-color: #f78a41;
      }

      .center {
        margin: auto;
        width: 50%;
        border: 3px solid green;
        padding: 10px;
      }

      .game-key{
        background-color: black;
        border: 2px solid white; 
        color: white; 
        height: 50px; 
        padding: 10px 5px; 
        text-align: center; 
        width: 5%; 
        display: inline-block; 
        font-size: 14px; 
        transition: all 0.2s ease-in-out; 
        cursor: pointer; 
        margin-bottom:0.5;
      }

      .game-key:hover{
        background-color: white;
        border: 2px solid black; 
        color: black; 
        transition: all 0.1s ease-in-out; 
        cursor: pointer; 
        margin-bottom: 0.5;
      }
      
      .blank-key{
        background-color: black;
        border: 2px solid black; 
        height: 50px; 
        text-align: center; 
        width: 5%; 
        display: inline-block; 
      }

      .endgame-key{
        background-color: rgb(0,100,0);
        border: 2px solid rgb(0,100,0); 
        color: rgb(0,200,0); 
        height: 50px; 
        text-align: center; 
        width: 100%; 
        display: inline-block; 
        font-size: 64px; 
        transition: all 0.2s ease-in-out; 
        cursor: pointer; 
        margin-bottom: 50px;
      }

      .endgame-key:hover{
        background-color: white;
        border: 2px solid black; 
        color: black; 
        transition: all 0.1s ease-in-out; 
        cursor: pointer; 
        margin-bottom: 0.5;
      }

    </style>
  </head>
  <body>
    <ul>
      <li><a href="https://skparab1.github.io">Home</a></li>
      <li><a href="https://skparab1.github.io/wordle/random">Wordle</a></li>
      <li><a href="https://skparab1.github.io/snake">Snake</a></li>
    </ul> 

    <h1>Snake game</h1>

    <!div class="center" style="width: 100%">
    <div style="float: left">
    <canvas class="myCanvas">
      <p>Rip ur browser doesnt support canvas :(( u shud switch to a better browser...</p>
      <canvas id="the-canvas" width="320" height="240" style="position:relative; right:300px;"></canvas>
    </canvas>
    </div>

    <script>

      // alr anindit here are the toggle constants
      const boardSize = 20; //so 20 means 20x20 and 40 would be 40x40 and you can change it to anything you want
      const speedfactor = 188; //about 200-these many pixels per second (but not exactly)
      const pixelbackground1 = 'rgb(0,150,0)'; // this is like the pixel background pattern
      const pixelbackground2 = 'rgb(0,190,0)'; // its in rgb but you can make it hex or hsv if u want
      // emphasis background colors
      const pixelbackground1EMP = 'rgb(0,120,0)';
      const pixelbackground2EMP = 'rgb(0,160,0)';
      const bordercolor = 'rgb(0,100,0)'; //bordercolor
      const snakecolor1 = 'rgb(0,0,100)'; //snakecolor1
      const snakecolor2 = 'rgb(0,0,255)'; //snakecolor2
      const snakeheadcolor = 'rgb(200,100,0)'; //apple color
      // arrays for the same things above for logistical things
      var snakecolor1ARR = [0,100,0]; //snakecolor1
      var snakecolor2ARR = [0,0,255]; //snakecolor2
      var snakeheadcolorARR = [200,100,0];; //apple color

      const applecolor = 'rgb(150,0,0)'; //apple color
      const seglength = 75; //snake segment length in pixels
      const addlength = 75; //increase snake length by these many pixels when it eats an apple
      const borderleniance = 0.5 // the game will ignore a wall hit as long as it is less than 0.5 boxes away from the border
      const rendertime = 10 // render every 10 snake circles
      const endcurtainspeed = 0.25 // seconds wait in between frames of each pixel expansion (for game over animation)
      var autopilot; // this is for fun but it turns on with the url parameter query

      if (window.location.href.includes('?autopilot=true')){
        autopilot = true;
      } else {
        autopilot = false;
      }

      // dont do anythign below this
      const turningPrecision = true;

      function drawline(x,y,x1,y1,clr){
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = clr;
        ctx.moveTo(x,y);
        ctx.lineTo(x1,y1)
        ctx.stroke();
      }

      function drawboard(){
        ctx.beginPath();
        let x = 0;
        let actx = window.innerWidth/4;
        let clrnow = pixelbackground1;
        while (x < boardSize+2){
          let y = 0;
          let acty = 0;
          while (y < boardSize+4){
            if (clrnow == pixelbackground1){
              clrnow = pixelbackground2;
            } else {
              clrnow = pixelbackground1;
            }
            ctx.fillStyle = clrnow;
            if (x == 0 || x == boardSize+1 || y == 0 || y == boardSize+1){
              let reserve = clrnow;
              ctx.fillStyle = bordercolor;
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
              clrnow = reserve;
            } else {
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
            }
            acty += (height)/(boardSize+2);
            y += 1;
            //console.log('drew smth');
            }
          
          if (clrnow == pixelbackground1){
            clrnow = pixelbackground2;
          } else {
            clrnow = pixelbackground1;
          }
          actx += (height)/(boardSize+2);
          x += 1;
        }
        let leniance = ((height)/(boardSize+2))*borderleniance;
        bounderies = [window.innerWidth/4+(height)/(boardSize+2)*1.5-leniance,(height)/(boardSize+2)*1.5-leniance,(window.innerWidth/4+height*((boardSize-1)/boardSize))-(height)/(boardSize+2)/2.5+leniance,height*(boardSize-1)/boardSize-(height)/(boardSize+2)/2+leniance];
      }

      function animateboard(){
        ctx.beginPath();
        (async () => {
          let anim = 0;
          while (anim < 101){
            let x = 0;
            let actx = window.innerWidth/4;
            let clrnow = pixelbackground1EMP;

            while (x < boardSize+2){
              let y = 0;
              let acty = 0;
              while (y < boardSize+4){
                
                if (clrnow == pixelbackground1EMP){
                  clrnow = pixelbackground2EMP;
                } else {
                  clrnow = pixelbackground1EMP;
                }

                //console.log(anim,'wut');
                ctx.fillStyle = clrnow;
                if (x == 0 || x == boardSize+1 || y == 0 || y == boardSize+1){
                  if (clrnow == pixelbackground1EMP){
                    clrnow = pixelbackground2EMP;
                  } else {
                    clrnow = pixelbackground1EMP;
                  }
                  let reserve = clrnow;
                  ctx.fillStyle = bordercolor;
                  ctx.fillRect(actx, acty, (height/(boardSize+2))*anim/100, (height/(boardSize+2))*anim/100);
                  clrnow = reserve;
                  //console.log(anim,'in first');
                } else {
                  //clrnow = 'rgb(0,0,0)';
                  ctx.fillStyle = clrnow;
                  ctx.fillRect(actx, acty, (height/(boardSize+2)), (height/(boardSize+2))*anim/100);
                  //console.log(anim,'in');
                }
                acty += (height)/(boardSize+2);
                y += 1;
                //console.log('drew smth');
                }
              
              if (clrnow == pixelbackground1EMP){
                clrnow = pixelbackground2EMP;
              } else {
                clrnow = pixelbackground1EMP;
              }
              actx += (height)/(boardSize+2);
              x += 1;
            }
            //console.log(anim,'in but out');
            await sleep(2);
            anim += 2;
          }
        })();
      }

      function drawcircle(x,y,rad,circlr){
        ctx.beginPath();
        ctx.fillStyle = circlr;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      function cir(x,y,rad,circlr,start,end){
        ctx.beginPath();
        ctx.fillStyle = circlr;
        ctx.arc(x, y, rad, start * Math.PI, end * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      function drawapple(x,y,rad){
        ctx.beginPath();
        ctx.fillStyle = applecolor;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      const canvas = document.querySelector('.myCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = window.innerWidth/2+window.innerWidth/4; 
      const height = canvas.height = window.innerHeight-100;
      var bounderies = [0,0,0,0];
      var score = 0;
      canvas.style.left = "100px";
      canvas.style.top = "100px";

      //canvas outline
      //ctx.strokeStyle = 'rgb(125,125,125)';
      ctx.strokeRect(0, 0, width, height);
      //console.log('printeddd');

      drawboard();

      var speed = ((height)/(boardSize+2))/(200-speedfactor); // 1/4 square/frame?
      let xpos = window.innerWidth/4+window.innerWidth/40+(height)/(boardSize+2)*2;
      let ypos = ((height)/(boardSize+2)*1.5)+(height)/(boardSize+2)*(boardSize/2);
      let startingpos = [xpos,ypos];
      var pointsArr = [xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
      var xd = 0;
      var yd = 0;
      var waiter = '';
      var waiter2 = '';
      var startwaiter = false;
      var applepos = [Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+window.innerWidth/4+window.innerWidth/40, Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+((height)/(boardSize+2)*1.5)];
      var scalefactor = window.innerWidth/2048;
      var initxpos = xpos;
      var initypos = ypos;
      var breaker = false;
      var eatwaiter = 0;
      var lastapple = [0,0];

      console.log(applepos);

      const sleep = ms => new Promise(res => setTimeout(res, ms));

      (async () => {
        let counter = 0;
        while ((xpos >= bounderies[0] && xpos <= bounderies[2] && ypos >= bounderies[1] && ypos <= bounderies[3])){ // took out waiters  || waiter != '' || waiter2 != ''
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          speed = speed * 1.0001;
          //await sleep(2);
          drawboard();
          let i = 0;
          while (i <= pointsArr.length-1){
            if (i > (pointsArr.length-15)){
              drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakeheadcolor);
            } else {
              if (i % seglength*2 < seglength){
                drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor1);
              } else {
                drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor2);
              }
            }

            //old overlapper
            // let j = 0;
            // if (j <= pointsArr.length-1 && false){
            //   if (pointsArr[i] == pointsArr[j] && pointsArr[i+1] == pointsArr[j+1] && i != j && pointsArr[j] != 0 && pointsArr[j+1] != 0 && pointsArr[j] != xpos && pointsArr[j] != ypos){
            //     // let z4 = document.getElementById('display');
            //     // z4.textContent = 'YOU HIT YOURSELF!';
            //     console.log('hit urself');
            //     //console.log(i,j);
            //     //console.log(pointsArr[i],pointsArr[j]);
            //   }
            //   j += 1;
            // }

            i += 2;
          }

          drawapple(applepos[0],applepos[1],(height)/(boardSize*2.2));
          xpos += xd;
          ypos += yd;
          counter += 1;
          await sleep(2);
          //console.log('drew at '+xpos+' '+ypos);
          pointsArr.push(xpos);
          pointsArr.push(ypos);
          pointsArr.shift();
          pointsArr.shift();

          if (Math.abs(xpos-applepos[0]) < 2 && Math.abs(ypos-applepos[1]) < 2){
            //basically you got it
            // set lastapple
            lastapple = applepos;

            //relocate apple
            applepos = [Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+window.innerWidth/4+window.innerWidth/40, Math.floor(Math.random()*(boardSize-2))*(height)/(boardSize+2)+(height)/(boardSize+2)+((height)/(boardSize+2)*1.5)];

            //ignore overlap for some time
            eatwaiter = 7;

            //update score
            score += 1;
            var z1 = document.getElementById('score');
            z1.textContent = 'Score: '+score;
            let z2 = document.getElementById('display');
            z2.textContent = 'Good Job!';

            //update length
            let z = 0;
            while (z < addlength){
              pointsArr.push(0);
              pointsArr.push(0);
              z += 1;
            }
          }

          eatwaiter -= 1;

          let ct3 = window.innerWidth/4+window.innerWidth/40;
          while (ct3 < xpos + (height)/(boardSize+2) && xd != 0){
            if (Math.abs(ct3-xpos) < 2){
              if (waiter == 'up'){
                xd = 0;
                yd = -speed;
              } else if (waiter == 'down'){
                xd = 0;
                yd = speed;
              }
              waiter = '';
              if (waiter2 == 'up'){
                xd = 0;
                yd = -speed;
              } else if (waiter2 == 'down'){
                xd = 0;
                yd = speed;
              }
              waiter2 = '';
            }
           ct3 += (height)/(boardSize+2);
          }

          ct3 = ((height)/(boardSize+2)*1.5);
          while (ct3 < ypos + (height)/(boardSize+2) && yd != 0){
            if (Math.abs(ct3-ypos) < 2){
              if (waiter == 'right'){
                xd = speed;
                yd = 0;
              } else if (waiter == 'left'){
                xd = -speed;
                yd = 0;
              }
              waiter = '';
              if (waiter2 == 'right'){
                xd = speed;
                yd = 0;
              } else if (waiter2 == 'left'){
                xd = -speed;
                yd = 0;
              }
              waiter2 = '';
            }
           ct3 += (height)/(boardSize+2);
          }
          //   ct1 += (height)/(boardSize+2);

          // overlap experiment below
          let overlapgetter = 0;
          while (overlapgetter < pointsArr.length){
            if (Math.abs(pointsArr[pointsArr.length-2]-pointsArr[overlapgetter]) < (height)/(boardSize+2)/2 && Math.abs(pointsArr[pointsArr.length-1]-pointsArr[overlapgetter+1]) < (height)/(boardSize+2)/2 && pointsArr[overlapgetter] != initxpos && pointsArr[overlapgetter] != 0 && pointsArr[overlapgetter+1] != initypos && pointsArr[overlapgetter+1] != 0 && Math.abs(pointsArr.length-2 -overlapgetter) > 75){ // no need for eatwaiter anymore but  && eatwaiter < 0
              //overlapped
              if (eatwaiter < 0 || ((Math.abs(pointsArr[pointsArr.length-2]-lastapple[0])) > (height)/(boardSize+2)/2 && (Math.abs(pointsArr[pointsArr.length-1]-lastapple[1])) > (height)/(boardSize+2)/2)){
                // checked to make sure wasnt last apple pos
                console.log(pointsArr.length-2,overlapgetter);
                console.log('overlapped');
                //alert('you lost');
                breaker = true;
                break;
              }
            }
            overlapgetter += 2;
          }

          if (breaker){
            break;
          }

          // autopilot stuff below
          if (autopilot){
            if (Math.abs(pointsArr[pointsArr.length-2]-applepos[0]) < 2*scalefactor){ // x coord is same and itsa not vertically moving
              if (pointsArr[pointsArr.length-1] > applepos[1]){ //snake is below apple
                waiter = 'up';
              } else {
                waiter = 'down';
              }
              console.log(pointsArr[pointsArr.length-2], applepos[0]);       // used to have  && yd != 0
            } else if (Math.abs(pointsArr[pointsArr.length-1]-applepos[1]) < 2*scalefactor){ // y coord is same
              if (pointsArr[pointsArr.length-2] > applepos[0]){ //snake is right of apple
                waiter = 'left';
              } else {
                waiter = 'right';
              }
              console.log(pointsArr[pointsArr.length-1], applepos[1]);
            }
          }

          if (autopilot){
            if (Math.abs(pointsArr[pointsArr.length-2]-applepos[0]) < 7*scalefactor){ // x coord is same and itsa not vertically moving
              if (pointsArr[pointsArr.length-1] > applepos[1]){ //snake is below apple
                waiter = 'up';
              } else {
                waiter = 'down';
              }
              console.log(pointsArr[pointsArr.length-2], applepos[0]);       // used to have  && yd != 0
            } else if (Math.abs(pointsArr[pointsArr.length-1]-applepos[1]) < 7*scalefactor){ // y coord is same
              if (pointsArr[pointsArr.length-2] > applepos[0]){ //snake is right of apple
                waiter = 'left';
              } else {
                waiter = 'right';
              }
              console.log(pointsArr[pointsArr.length-1], applepos[1]);
            }

            if (Math.abs(pointsArr[pointsArr.length-2] - bounderies[0]) <= 25*scalefactor && yd == 0){ // close to left boundery
              if (pointsArr[pointsArr.length-1] > applepos[1]){ //snake is below apple
                waiter = 'up';
              } else {
                waiter = 'down';
              }
              console.log('got triggered1');
            }
            if (Math.abs(pointsArr[pointsArr.length-1] - bounderies[1]) <= 25*scalefactor && xd == 0){
              if (pointsArr[pointsArr.length-2] > applepos[0]){ //snake is right of apple
                waiter = 'left';
              } else {
                waiter = 'right';
              }
              console.log('got triggered');
            }
            if (Math.abs(pointsArr[pointsArr.length-2] - bounderies[2]) <= 25*scalefactor && yd == 0){
              if (pointsArr[pointsArr.length-1] > applepos[1]){ //snake is below apple
                waiter = 'up';
              } else {
                waiter = 'down';
              }
            }
            if (Math.abs(pointsArr[pointsArr.length-1] - bounderies[3]) <= 25*scalefactor && xd == 0){
              if (pointsArr[pointsArr.length-2] > applepos[0]){ //snake is right of apple
                waiter = 'left';
              } else {
                waiter = 'right';
              }
            }

          }
          console.log('end of biggest loop ', breaker);
          if (breaker){
            break;
            breaker = false;
          }
        }
        //console.log('did whole thing');
        let z3 = document.getElementById('display');
        z3.textContent = 'Game over! reload to play again';
        //alert('You lost');

        //set up buttons for endgame

        let displaydiv = document.getElementById('endgame-display');
        let displaydiv1 = document.getElementById('endgame-display1');
        let play_again = document.getElementById('play_again');
        let leaderboard = document.getElementById('leaderboard');
        displaydiv.style.left = bounderies[0]+(1/10)*(bounderies[2]-bounderies[0])+"px";
        displaydiv.style.top = bounderies[1]+(1/5*(bounderies[3]-bounderies[1]))+"px";
        displaydiv.style.height = bounderies[0]+(1/5*(bounderies[2]-bounderies[0]))+"px";
        displaydiv1.style.left = bounderies[0]+(1/10)*(bounderies[2]-bounderies[0])+"px";
        displaydiv1.style.top = bounderies[1]+(4/5)*(bounderies[3]-bounderies[1])+"px";
        displaydiv1.style.height = bounderies[0]+(1/5*(bounderies[2]-bounderies[0]))+"px";
        play_again.style.width = (8/10)*(bounderies[2]-bounderies[0])+"px";
        play_again.style.height = (1/5)*(bounderies[3]-bounderies[1])+"px";
        leaderboard.style.width = (8/10)*(bounderies[2]-bounderies[0])+"px";
        leaderboard.style.height = (1/5)*(bounderies[3]-bounderies[1])+"px";
        //displaydiv.style.paddingBottom = (3/5)*(bounderies[3]-bounderies[1])+"px";
        //displaydiv.style.margin-bottom = 50*scalefactor+"px";

        // game over animation
        ctx.beginPath;

        (async () => {

          setTimeout(function(){

            (async () => {
              let z = 0;
              while (z < 50){
                //drawboard();
                let i = 0;
                while (i <= pointsArr.length-1){
                  if (i <= (pointsArr.length-15)){
                    if (i % seglength*2 < seglength){
                      cir(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor1,0,2);
                    } else {
                      cir(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor2,0,2);
                    }
                  } else {
                    // this is the head
                    let se = 0;
                    while (se < 2){
                      cir(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2)+z, snakeheadcolor,se,se+0.1);
                      se += 0.2;
                    }
                  }
                  i += 2;
                }
                await sleep(2);
                z += (55-z)/20;
              }
            })();
          },0);

          setTimeout(function(){
            animateboard();
          }, 1200);

          setTimeout(function(){
            // this might be cool if we do it right
            // ok so basically draw the board but do it nicely
            
            (async () => {
            
              // ok now do what anindit said

              ctx.beginPath;
              ctx.fillStyle = bordercolor;

              let endgame = 0;
              let bordereraser = 0;
              while (endgame <= bounderies[3] - (bounderies[3]-bounderies[1])/2){
                ctx.fillStyle = 'rgb(0,0,0)';
                ctx.fillRect(bounderies[0]-(height)/(boardSize+2), bounderies[1], -bordereraser, bounderies[3]-bounderies[1]);
                ctx.fillRect(bounderies[0], bounderies[1], bounderies[2]-bounderies[0], -bordereraser);
                ctx.fillRect(bounderies[2]+(height)/(boardSize+2), bounderies[1], bordereraser, bounderies[3]-bounderies[1]);
                ctx.fillRect(bounderies[2], bounderies[3], bounderies[2]-bounderies[0], bordereraser);
                ctx.fillStyle = bordercolor;
                ctx.fillRect(bounderies[0]-(height)/(boardSize+2), bounderies[1]-(height)/(boardSize+2), bounderies[3]-bounderies[1]+2*(height)/(boardSize+2), endgame+(height)/(boardSize+2))
                ctx.fillRect(bounderies[0]-(height)/(boardSize+2), bounderies[1]+bounderies[3], bounderies[3]-bounderies[1]+2*(height)/(boardSize+2), -endgame)
                endgame += 4;
                bordereraser += 1;
                await sleep(endcurtainspeed);
              }
              endgame = 0;
              while (endgame <= bounderies[3]-(height)/(boardSize+2)){
                ctx.fillStyle = pixelbackground2;
                ctx.fillRect(bounderies[0],bounderies[1],bounderies[2]-bounderies[0],bounderies[3]-bounderies[1]);
                

                ctx.fillStyle = bordercolor;
                ctx.fillRect(bounderies[0]-(height)/(boardSize+2), bounderies[1]+(bounderies[3]-bounderies[1])/2, bounderies[3]-bounderies[1]+2*(height)/(boardSize+2), bounderies[3]-endgame)
                ctx.fillRect(bounderies[0]-(height)/(boardSize+2), bounderies[1]+(bounderies[3]-bounderies[1])/2, bounderies[3]-bounderies[1]+2*(height)/(boardSize+2), -(bounderies[3]-endgame))
                endgame += 10;
                await sleep(endcurtainspeed);
              }
              displaydiv.style.display = "inline-block";
              displaydiv1.style.display = "inline-block";
              endgame = 0;
              ctx.strokeStyle = 'rgb(0,0,0)';
              ctx.font = 64*scalefactor+"px Arial";
              ctx.lineWidth = '10px';
              while (endgame <= bounderies[3]/2+(height)/(boardSize+2)/2){
                ctx.fillStyle = pixelbackground2;
                ctx.fillRect(bounderies[0],bounderies[1],bounderies[2]-bounderies[0],bounderies[3]-bounderies[1]);
                //ctx.strokeRect(bounderies[0],bounderies[1]+(bounderies[3]-bounderies[1])/2-(height)/(boardSize+2),(bounderies[2]-bounderies[0])+(height)/(boardSize+2),2*(height)/(boardSize+2));
                ctx.fillStyle = 'rgb(0,0,0)';
                ctx.fillText("GAME OVER!", bounderies[0]+(bounderies[2]-bounderies[0])/4-(height)/(boardSize+2), bounderies[1]+(bounderies[3]-bounderies[1])/2+(height)/(boardSize+2)*7/8); 
                ctx.fillStyle = bordercolor;
                ctx.fillRect(bounderies[0], bounderies[1]+(bounderies[3]-bounderies[1])/2-(height)/(boardSize+2),(bounderies[2]-bounderies[0])/2-endgame, (height)/(boardSize+2)*2);
                ctx.fillRect(bounderies[2], bounderies[1]+(bounderies[3]-bounderies[1])/2-(height)/(boardSize+2),-((bounderies[2]-bounderies[0])/2-endgame), (height)/(boardSize+2)*2);
                endgame += 10;
                await sleep(endcurtainspeed);
              }
            })();
          },1500);
        })();
      })();

      (async () => {
      window.addEventListener("keydown", function(event) {

        if (event.defaultPrevented) {
          return;
        }

        if (!startwaiter){
          xd = speed;
          startwaiter = true;
          let z = document.getElementById('display');
          z.textContent = '';
        }

        const ctx = canvas.getContext('2d');
        
        let actkey = event.code.replace('Key','')
        let filterletters = 'QWERTYUIOPASDFGHJKLZXCVBNM';
        console.log('pressed'+actkey);

        if (waiter == ''){
          if (actkey == 'ArrowLeft' || actkey == 'A'){
            waiter = 'left';
          }
          if (actkey == 'ArrowRight' || actkey == 'D'){
            waiter = 'right';
          }
          if (actkey == 'ArrowUp' || actkey == 'W'){
            waiter = 'up';
          }
          if (actkey == 'ArrowDown' || actkey == 'S'){
            waiter = 'down';
          }
        } else {
          if (actkey == 'ArrowLeft' || actkey == 'A'){
            waiter2 = 'left';
          }
          if (actkey == 'ArrowRight' || actkey == 'D'){
            waiter2 = 'right';
          }
          if (actkey == 'ArrowUp' || actkey == 'W'){
            waiter2 = 'up';
          }
          if (actkey == 'ArrowDown' || actkey == 'S'){
            waiter2 = 'down';
          }

          let g = document.getElementById('ap notif');
          g.textcontent = 'Autopilot: On';
        }

        // i think i get how to do it
        // just have a waiter variable thats set by this 
        // and then chnage directsion when it gets to the ting and clear the waiter

        //actkey is just the thing

        }, true);
      })();

    </script>
    <div id="endgame-display" style="position: absolute; left: 500px; top: 100px; display: none">
      <button class="endgame-key" id="play_again" onclick="window.location.reload();" >Play again</button>
    </div>
    <div id="endgame-display1" style="position: absolute; left: 500px; top: 100px; display: none">
      <button class="endgame-key" id="leaderboard" onclick="window.location.href='https:skparab1.github.io/snake/leaderboard'">Leaderboard</button>
    </div>

    </div style="float: left">
      <h1 id="score">Score: 0</h1>
      <h1 id="display">Press any key to start</h1><br>
      <h1 id="ap notif">Autopilot: Off</h1>
    </div>
    <!/div>
    <!h1 style="color:rgb(225, 252, 71);"> Note: if the game canvas does not cover the whole height of the screen, then reload.</h1>
    <h1 style="color:white"> Game controls</h1>
    <button class="blank-key"></button>
    <button class="game-key" onclick="up();">↑</button>
    <button class="blank-key"></button>
    <br>
    <button class="game-key" onclick="left();">←</button>
    <button class="game-key" onclick="down();">↓</button>
    <button class="game-key" onclick="right();">→</button>

    <script>
      function left(){
        waiter = 'left';
      }
      function up(){
        waiter = 'up';
      }
      function down(){
        waiter = 'down';
      }
      function right(){
        waiter = 'right';
      }
    </script>
  </body>
</html>
