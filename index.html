<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake game</title>
    <style>
          body {background-color: rgb(0, 0, 0);}
      body {
        margin: 0;
        overflow: hidden;
      }

      h1{
        color:rgb(200, 200, 200);
      }

      ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        background-color: #555555;
      }
      li {
        display: inline;
        float: left;
      }
      li a {
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
      }

      li a:hover {
        background-color: #f78a41;
      }

      .center {
        margin: auto;
        width: 50%;
        border: 3px solid green;
        padding: 10px;
      }

    </style>
  </head>
  <body>
    <ul>
      <li><a href="https://skparab1.github.io">Home</a></li>
      <li><a href="https://skparab1.github.io/wordle/random">Wordle</a></li>
      <li><a href="https://skparab1.github.io/snake">Snake</a></li>
    </ul> 

    <h1>Snake game</h1>

    <canvas class="myCanvas">
      <p>Rip ur browser doesnt support canvas :(( u shud switch to a better browser...</p>
      <canvas id="the-canvas" width="320" height="240" style="position:relative; right:300px;"></canvas>
    </canvas>

    <script>

      // alr anindit here are the toggle constants
      const boardSize = 20; //so 20 means 20x20 and 40 would be 40x40 and you can change it to anything you want
      const speedfactor = 75; //about these many pixels per second (but not exactly)
      const pixelbackground1 = 'rgb(0,150,0)'; // this is like the pixel background pattern
      const pixelbackground2 = 'rgb(0,190,0)'; // its in rgb but you can make it hex or hsv if u want
      const bordercolor = 'rgb(0,100,0)'; //bordercolor
      const snakecolor = 'rgb(0,0,150)'; //snakecolor
      const snakeheadcolor = 'rgb(200,100,0)'; //apple color
      const applecolor = 'rgb(150,0,0)'; //apple color
      
      // dont do anythign below this
      const turningPrecision = true;

      function drawline(x,y,x1,y1,clr){
        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.strokeStyle = clr;
        ctx.moveTo(x,y);
        ctx.lineTo(x1,y1)
        ctx.stroke();
      }

      function drawboard(){
        ctx.beginPath();
        let x = 0;
        let actx = window.innerWidth/4;
        let clrnow = pixelbackground1;
        while (x < boardSize+2){
          let y = 0;
          let acty = 0;
          while (y < boardSize+4){
            if (clrnow == pixelbackground1){
              clrnow = pixelbackground2;
            } else {
              clrnow = pixelbackground1;
            }
            ctx.fillStyle = clrnow;
            if (x == 0 || x == boardSize+1 || y == 0 || y == boardSize+1){
              let reserve = clrnow;
              ctx.fillStyle = bordercolor;
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
              clrnow = reserve;
            } else {
              ctx.fillRect(actx, acty, height/(boardSize+2), height/(boardSize+2));
            }
            acty += (height)/(boardSize+2);
            y += 1;
            //console.log('drew smth');
            }
          
          if (clrnow == pixelbackground1){
            clrnow = pixelbackground2;
          } else {
            clrnow = pixelbackground1;
          }
          actx += (height)/(boardSize+2);
          x += 1;
        }
        bounderies = [window.innerWidth/4,0,(window.innerWidth/4+height*((boardSize-1)/boardSize)),height*(boardSize-1)/boardSize];
      }

      function drawcircle(x,y,rad,circlr){
        ctx.beginPath();
        ctx.fillStyle = circlr;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      function drawapple(x,y){
        ctx.beginPath();
        ctx.fillStyle = applecolor;
        ctx.arc(x, y, rad, 0, 2 * Math.PI); //-((height)/(boardSize+2)/2)
        ctx.fill(); 
      }

      const canvas = document.querySelector('.myCanvas');
      const ctx = canvas.getContext('2d');
      const width = canvas.width = window.innerWidth/2+window.innerWidth/4; 
      const height = canvas.height = window.innerHeight-100;
      var bounderies = [0,0,0,0];
      canvas.style.left = "100px";
      canvas.style.top = "100px";

      //canvas outline
      //ctx.strokeStyle = 'rgb(125,125,125)';
      ctx.strokeRect(0, 0, width, height);
      //console.log('printeddd');

      drawboard();

      var speed = ((height)/(boardSize+2))/(100-speedfactor); // 1/4 square/frame?
      let xpos = window.innerWidth/4+window.innerWidth/40;
      let ypos = ((height)/(boardSize+2)*1.5);
      var pointsArr = [xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,xpos,ypos,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
      var xd = 0;
      var yd = speed;
      var waiter = '';

      const sleep = ms => new Promise(res => setTimeout(res, ms));

      (async () => {
        let counter = 0;
        while (xpos >= bounderies[0] && xpos <= bounderies[2] && ypos >= bounderies[1] && ypos <= bounderies[3]){
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          //await sleep(2);
          drawboard();
          let i = 0;
          while (i <= pointsArr.length-1){
            if (i > (pointsArr.length-10)){
              drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakeheadcolor);
            } else {
              drawcircle(pointsArr[i],pointsArr[i+1],(height)/(boardSize*2.2), snakecolor);
            }
            i += 2;
          }
          xpos += xd;
          ypos += yd;
          counter += 1;
          await sleep(2);
          //console.log('drew at '+xpos+' '+ypos);
          pointsArr.push(xpos);
          pointsArr.push(ypos);
          pointsArr.shift();
          pointsArr.shift();

          let ct3 = window.innerWidth/4+window.innerWidth/40;
          while (ct3 < xpos + (height)/(boardSize+2) && xd != 0){
            if (Math.abs(ct3-xpos) < 2){
              if (waiter == 'up'){
                xd = 0;
                yd = -speed;
              } else if (waiter == 'down'){
                xd = 0;
                yd = speed;
              }
              waiter = '';
            }
           ct3 += (height)/(boardSize+2);
          }

          ct3 = ((height)/(boardSize+2)*1.5);
          while (ct3 < ypos + (height)/(boardSize+2) && yd != 0){
            if (Math.abs(ct3-ypos) < 2){
              if (waiter == 'right'){
                xd = speed;
                yd = 0;
              } else if (waiter == 'left'){
                xd = -speed;
                yd = 0;
              }
              waiter = '';
            }
           ct3 += (height)/(boardSize+2);
          }
          //   ct1 += (height)/(boardSize+2);
        }
        //console.log('did whole thing');
        alert('You lost');
      })();

      (async () => {
      window.addEventListener("keydown", function(event) {

        if (event.defaultPrevented) {
          return;
        }

        const ctx = canvas.getContext('2d');
        
        let actkey = event.code.replace('Key','')
        let filterletters = 'QWERTYUIOPASDFGHJKLZXCVBNM';
        console.log('pressed'+actkey);

        if (actkey == 'ArrowLeft' || actkey == 'A'){
          waiter = 'left';
        }
        if (actkey == 'ArrowRight' || actkey == 'D'){
          // while (ct1 < ypos){
          //   ct1 += (height)/(boardSize+2);
          // }
          waiter = 'right';
        }
        if (actkey == 'ArrowUp' || actkey == 'W'){
          waiter = 'up';
        }
        if (actkey == 'ArrowDown' || actkey == 'S'){
          waiter = 'down';
        }

        // i think i get how to do it
        // just have a waiter variable thats set by this 
        // and then chnage directsion when it gets to the ting and clear the waiter

        //actkey is just the thing

        }, true);
      })();

    </script>

    <script type="text/javascript">

      function getMousePosition(canvas, event) {
          let rect = canvas.getBoundingClientRect();
          let x = event.clientX - rect.left;
          let y = event.clientY - rect.top;
          console.log("Coordinate x: " + x, 
                      "Coordinate y: " + y);
          // these are clickables
          if (x >= 110 && x <= 340 && y >= 180 && y <= 240){
            //window.open('https://skparab1.github.io/login/auth=false&pwdchallenge=true&goto=skparab1.github.io&s&homepage',"_self")
          }
          if (x >= 388 && x <= 612 && y >= 180 && y <= 240){
            //window.open('https://skparab1.github.io/search/&software=false&article=false',"_self")
          }
          // if (x >= 110 && x <= 340 && y >= 180 && y <= 240){
          //   window.open('https://skparab1.github.io/login/auth=false&pwdchallenge=true&goto=skparab1.github.io&s&homepage',"_self")
          // }
      }

      let canvasElem = document.querySelector("canvas");
        
      canvasElem.addEventListener("mousedown", function(e)
      {
          getMousePosition(canvasElem, e);
      });
    </script>
    <h1 style="color:rgb(225, 252, 71);"></h1> Skparab1 Software</h1>
    <h1 style="color:rgb(225, 252, 71);"></h1> hello</h1>
    <h1 style="color:rgb(225, 252, 71);"> If you see this then you probably should reload so that the canvas auto resizes</h1>
    <h1 style="color:rgb(225, 252, 71);"></h1> Skparab1 Software</h1>
  </body>
</html>
